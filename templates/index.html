<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Panel Twitch Clips</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="container">
    <header>
      <h1>Panel Twitch Clips</h1>
      <div class="actions">
        <button id="btn-update" class="btn">Od≈õwie≈º streamer√≥w twitch</button>
        <button id="btn-report" class="btn">Generuj raport Twitch</button>
        <button id="btn-kick" class="btn">Generuj raport Kick</button>
        <div id="kick-report-container"></div>

      </div>
      <div id="status" class="status"></div>
    </header>

    <main id="raport-container"></main>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const raportContainer = document.getElementById('raport-container');

    document.getElementById('btn-kick').onclick = () => {
      fetch('/api/generate-raport-kick')
        .then(() => pollKick());
    };

    function pollKick() {
      fetch('/api/report-kick-ready')
        .then(r => r.json())
        .then(j => {
          if (j.ready) {
            fetch('/raport-kick-fragment')
              .then(r => r.text())
              .then(html => {
              document.getElementById('kick-report-container').innerHTML = html;
            });
        } else {
        setTimeout(pollKick, 2000);
      }
    });
}


    // 1) Od≈õwie≈º streamer√≥w
    async function runUpdate() {
      statusEl.textContent = 'üîÑ Od≈õwie≈ºanie streamer√≥w‚Ä¶';
      try {
        const res = await fetch('/api/update-streamers');
        const obj = await res.json();
        statusEl.textContent = obj.message || obj.error;
      } catch (e) {
        statusEl.textContent = 'B≈ÇƒÖd: ' + e;
      }
    }

    // 2) Generowanie raportu i pollowanie gotowo≈õci
    async function runReport() {
      statusEl.textContent = 'üïí Rozpoczynam generowanie‚Ä¶';
      await fetch('/api/generate-raport');       // odpala Popen w tle
      statusEl.textContent = '‚åõ Czekam na raport‚Ä¶';
      const poll = setInterval(async () => {
        const r = await fetch('/api/report-ready');
        const { ready } = await r.json();
        if (ready) {
          clearInterval(poll);
          statusEl.textContent = '‚úÖ Raport gotowy!';
          loadReportFragment();
        }
      }, 5000);
    }

    // 3) Pobranie i wstrzykniƒôcie fragmentu raportu
    async function loadReportFragment() {
      const html = await fetch('/raport-fragment').then(r => r.text());
      raportContainer.innerHTML = html;
      initReportFiltersAndStats();  // <-- nowa funkcja
    }

    // 4) Inicjalizacja dropdown√≥w i aplikacja filtr√≥w
function initReportFiltersAndStats() {
  // 1. Toggle dropdown√≥w
  document.querySelectorAll('.dropdown').forEach(dd => {
    dd.querySelector('button').addEventListener('click', () => {
      dd.classList.toggle('open');
    });
  });

  // 2. Pobierz wszystkie wiersze tabeli
  const rows = Array.from(document.querySelectorAll('#report-table tbody tr'));

  // 3. Funkcja robiƒÖca filtr + live statystyki
  function applyFiltersAndStats() {
    // a) co ignorujemy?
    const ignoredStreamers = new Set(
      Array.from(document.querySelectorAll('.filter-streamer'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );
    const ignoredCategories = new Set(
      Array.from(document.querySelectorAll('.filter-category'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );

    // b) filtrujemy i zbieramy widoczne wiersze
    const visibleRows = [];
    rows.forEach(row => {
      const st = row.dataset.streamer, ct = row.dataset.category;
      const hidden = ignoredStreamers.has(st) || ignoredCategories.has(ct);
      row.style.display = hidden ? 'none' : '';
      if (!hidden) visibleRows.push(row);
    });

    // c) obliczamy statystyki na podstawie visibleRows
    const total = visibleRows.length;
    const catCounts = {};
    const strCounts = {};
    visibleRows.forEach(r => {
      catCounts[r.dataset.category] = (catCounts[r.dataset.category] || 0) + 1;
      strCounts[r.dataset.streamer] = (strCounts[r.dataset.streamer] || 0) + 1;
    });
    const topCats = Object.entries(catCounts)
      .sort((a,b) => b[1] - a[1]).slice(0,3);
    const topStr = Object.entries(strCounts)
      .sort((a,b) => b[1] - a[1]).slice(0,3);

    // d) wstawiamy do DOM
    document.getElementById('stats-total').textContent = total;
    document.getElementById('stats-categories').textContent =
      topCats.map(([c,n]) => `${c} (${n})`).join(', ');
    document.getElementById('stats-streamers').textContent =
      topStr.map(([s,n]) => `${s} (${n})`).join(', ');
  }

  // 4. Pod≈ÇƒÖczamy przyciski ‚ÄûZastosuj‚Äù
  document.getElementById('apply-streamers').addEventListener('click', () => {
    applyFiltersAndStats();
    document.getElementById('dd-streamers').classList.remove('open');
  });
  document.getElementById('apply-categories').addEventListener('click', () => {
    applyFiltersAndStats();
    document.getElementById('dd-categories').classList.remove('open');
  });

  // 5. Pierwsze uruchomienie (wewnƒÖtrz init)
  applyFiltersAndStats();
}

    // Pod≈ÇƒÖczamy eventy do przycisk√≥w
    document.getElementById('btn-update').addEventListener('click', runUpdate);
    document.getElementById('btn-report').addEventListener('click', runReport);
  </script>
</body>
</html>
