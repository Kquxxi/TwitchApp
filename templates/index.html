<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Panel Twitch Clips</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="container">
    <header>
      <h1>Panel Twitch Clips</h1>
      <div class="actions">
        <button id="btn-update" class="btn">Od≈õwie≈º streamer√≥w twitch</button>
        <button id="btn-report" class="btn">Generuj raport Twitch</button>
        <button id="btn-kick" class="btn">Generuj raport Kick</button>
        <div id="kick-report-container"></div>

      </div>
      <div id="status" class="status"></div>
    </header>

    <main id="raport-container"></main>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const raportContainer = document.getElementById('raport-container');

    document.getElementById('btn-kick').onclick = () => {
      fetch('/api/generate-raport-kick')
        .then(() => pollKick());
    };

function pollKick() {
  fetch('/api/report-kick-ready')
    .then(r => r.json())
    .then(j => {
      if (j.ready) {
        fetch('/raport-kick-fragment')
          .then(r => r.text())
          .then(html => {
            // 1) wstrzykniƒôcie HTML-a
            const kc = document.getElementById('kick-report-container');
            kc.innerHTML = html;
            // 2) inicjalizacja filtr√≥w/statystyk TYLKO w kontenerze Kicka
            initReportFiltersAndStats(kc);
          });
      } else {
        setTimeout(pollKick, 2000);
      }
    });
}

    // 1) Od≈õwie≈º streamer√≥w
    async function runUpdate() {
      statusEl.textContent = 'üîÑ Od≈õwie≈ºanie streamer√≥w‚Ä¶';
      try {
        const res = await fetch('/api/update-streamers');
        const obj = await res.json();
        statusEl.textContent = obj.message || obj.error;
      } catch (e) {
        statusEl.textContent = 'B≈ÇƒÖd: ' + e;
      }
    }

    // 2) Generowanie raportu i pollowanie gotowo≈õci
    async function runReport() {
      statusEl.textContent = 'üïí Rozpoczynam generowanie‚Ä¶';
      await fetch('/api/generate-raport');       // odpala Popen w tle
      statusEl.textContent = '‚åõ Czekam na raport‚Ä¶';
      const poll = setInterval(async () => {
        const r = await fetch('/api/report-ready');
        const { ready } = await r.json();
        if (ready) {
          clearInterval(poll);
          statusEl.textContent = '‚úÖ Raport gotowy!';
          loadReportFragment();
        }
      }, 5000);
    }

    // 3) Pobranie i wstrzykniƒôcie fragmentu raportu
    async function loadReportFragment() {
      const html = await fetch('/raport-fragment').then(r => r.text());
      raportContainer.innerHTML = html;
      initReportFiltersAndStats(raportContainer);  // <-- nowa funkcja
    }

    // 4) Inicjalizacja dropdown√≥w i aplikacja filtr√≥w
function initReportFiltersAndStats(root) {
  // 1. Toggle dropdown√≥w tylko wewnƒÖtrz root
  root.querySelectorAll('.dropdown').forEach(dd => {
    dd.querySelector('button').addEventListener('click', () => {
      dd.classList.toggle('open');
    });
  });

  // 2. Pobierz wszystkie wiersze tabeli wewnƒÖtrz root
  const rows = Array.from(root.querySelectorAll('#report-table tbody tr'));

  // 3. Funkcja filtrujƒÖca + aktualizujƒÖca statystyki
  function applyFiltersAndStats() {
    // a) streamerzy
    const ignoredStreamers = new Set(
      Array.from(root.querySelectorAll('.filter-streamer'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );
    // b) kategorie
    const ignoredCategories = new Set(
      Array.from(root.querySelectorAll('.filter-category'))
        .filter(cb => !cb.checked).map(cb => cb.value)
    );

    const visible = [];
    rows.forEach(row => {
      const st = row.dataset.streamer, ct = row.dataset.category;
      const hide = ignoredStreamers.has(st) || ignoredCategories.has(ct);
      row.style.display = hide ? 'none' : '';
      if (!hide) visible.push(row);
    });

    // c) oblicz stats
    const total = visible.length;
    const catCounts = {}, strCounts = {};
    visible.forEach(r => {
      catCounts[r.dataset.category] = (catCounts[r.dataset.category]||0)+1;
      strCounts[r.dataset.streamer]  = (strCounts[r.dataset.streamer]||0)+1;
    });
    const topCats = Object.entries(catCounts)
      .sort((a,b)=>b[1]-a[1]).slice(0,3);
    const topStr = Object.entries(strCounts)
      .sort((a,b)=>b[1]-a[1]).slice(0,3);

    // d) wstaw do root, nie do document
    root.querySelector('#stats-total').textContent = total;
    root.querySelector('#stats-categories').textContent =
      topCats.map(([c,n])=>`${c} (${n})`).join(', ');
    root.querySelector('#stats-streamers').textContent =
      topStr.map(([s,n])=>`${s} (${n})`).join(', ');
  }

  // 4. Pod≈ÇƒÖcz przyciski tylko wewnƒÖtrz root
  root.querySelector('#apply-streamers').addEventListener('click', ()=>{
    applyFiltersAndStats();
    root.querySelector('#dd-streamers').classList.remove('open');
  });
  root.querySelector('#apply-categories').addEventListener('click', ()=>{
    applyFiltersAndStats();
    root.querySelector('#dd-categories').classList.remove('open');
  });

  // 5. Pierwsze wyliczenie
  applyFiltersAndStats();
}

    // Pod≈ÇƒÖczamy eventy do przycisk√≥w
    document.getElementById('btn-update').addEventListener('click', runUpdate);
    document.getElementById('btn-report').addEventListener('click', runReport);
  </script>
</body>
</html>
